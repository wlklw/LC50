<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="js/fonts/NotoSansTC-normal.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const unitSelect = document.getElementById('unit-select');
            const customUnitInput = document.getElementById('custom-unit-input');
            const dataTable1 = document.getElementById('data-table-1');
            const dataTable2 = document.getElementById('data-table-2');
            const dataTable3 = document.getElementById('data-table-3');
            const addRowBtn1 = document.getElementById('add-row-btn-1');
            const addRowBtn2 = document.getElementById('add-row-btn-2');
            const addRowBtn3 = document.getElementById('add-row-btn-3');
            const calculateBtn = document.getElementById('calculate-btn');
            const exportPdfBtn = document.getElementById('export-pdf-btn');
            const exportPngBtn = document.getElementById('export-png-btn');
            const exportJpgBtn = document.getElementById('export-jpg-btn');
            const exportSvgBtn = document.getElementById('export-svg-btn');
            const resetBtn = document.getElementById('reset-btn');
            const resultsSection = document.getElementById('results-section');
            const resultsGroup1 = document.getElementById('results-group-1');
            const resultsGroup2 = document.getElementById('results-group-2');
            const resultsGroup3 = document.getElementById('results-group-3');
            const validationInfo = document.getElementById('validation-info');
            const validationDetails = document.getElementById('validation-details');
            
            // 組名輸入框
            const group1NameInput = document.getElementById('group1-name');
            const group2NameInput = document.getElementById('group2-name');
            const group3NameInput = document.getElementById('group3-name');
            
            let probitChart;

            // 更新組名顯示
            function updateGroupNames() {
                document.getElementById('group1-title').textContent = `第一組數據 (${group1NameInput.value})`;
                document.getElementById('group2-title').textContent = `第二組數據 (${group2NameInput.value}) - 可選`;
                document.getElementById('group3-title').textContent = `第三組數據 (${group3NameInput.value}) - 可選`;
                
                document.getElementById('results-title-1').textContent = `第一組數據 (${group1NameInput.value})`;
                document.getElementById('results-title-2').textContent = `第二組數據 (${group2NameInput.value})`;
                document.getElementById('results-title-3').textContent = `第三組數據 (${group3NameInput.value})`;
            }
            
            // 監聽組名變更
            group1NameInput.addEventListener('input', updateGroupNames);
            group2NameInput.addEventListener('input', updateGroupNames);
            group3NameInput.addEventListener('input', updateGroupNames);
            
            // 初始化組名
            updateGroupNames();

            // 處理自訂單位輸入框的顯示
            unitSelect.addEventListener('change', () => {
                if (unitSelect.value === 'custom') {
                    customUnitInput.style.display = 'inline-block';
                } else {
                    customUnitInput.style.display = 'none';
                }
            });

            // 鍵盤導航功能
            function setupKeyboardNavigation() {
                const allInputs = document.querySelectorAll('.data-table input[type="number"]');
                
                allInputs.forEach((input, index) => {
                    input.addEventListener('keydown', (e) => {
                        let nextIndex = -1;
                        
                        switch(e.key) {
                            case 'ArrowDown':
                                e.preventDefault();
                                nextIndex = findNextRowInput(input, 1);
                                break;
                            case 'ArrowUp':
                                e.preventDefault();
                                nextIndex = findNextRowInput(input, -1);
                                break;
                            case 'ArrowRight':
                            case 'Tab':
                                if (e.key === 'Tab' && e.shiftKey) break;
                                e.preventDefault();
                                nextIndex = findNextColumnInput(input, 1);
                                break;
                            case 'ArrowLeft':
                                e.preventDefault();
                                nextIndex = findNextColumnInput(input, -1);
                                break;
                            case 'Enter':
                                e.preventDefault();
                                nextIndex = findNextRowInput(input, 1);
                                break;
                        }
                        
                        if (nextIndex !== -1) {
                            const nextInput = document.querySelectorAll('.data-table input[type="number"]')[nextIndex];
                            if (nextInput) {
                                nextInput.focus();
                                nextInput.select();
                            }
                        }
                    });
                    
                    // 視覺反饋
                    input.addEventListener('focus', () => {
                        input.classList.add('keyboard-focused');
                    });
                    
                    input.addEventListener('blur', () => {
                        input.classList.remove('keyboard-focused');
                    });
                });
            }
            
            function findNextRowInput(currentInput, direction) {
                const allInputs = Array.from(document.querySelectorAll('.data-table input[type="number"]'));
                const currentIndex = allInputs.indexOf(currentInput);
                const currentRow = currentInput.closest('tr');
                const currentTable = currentInput.closest('table');
                const currentColumn = Array.from(currentRow.querySelectorAll('input[type="number"]')).indexOf(currentInput);
                
                let nextRow;
                if (direction > 0) {
                    nextRow = currentRow.nextElementSibling;
                    if (!nextRow) {
                        // 尋找下一個表格的第一行
                        let nextTable = currentTable.parentNode;
                        while (nextTable && nextTable.nextElementSibling) {
                            nextTable = nextTable.nextElementSibling;
                            const foundTable = nextTable.querySelector('.data-table');
                            if (foundTable) {
                                nextRow = foundTable.querySelector('tbody tr');
                                break;
                            }
                        }
                    }
                } else {
                    nextRow = currentRow.previousElementSibling;
                    if (!nextRow) {
                        // 尋找上一個表格的最後一行
                        let prevTable = currentTable.parentNode;
                        while (prevTable && prevTable.previousElementSibling) {
                            prevTable = prevTable.previousElementSibling;
                            const foundTable = prevTable.querySelector('.data-table');
                            if (foundTable) {
                                const rows = foundTable.querySelectorAll('tbody tr');
                                nextRow = rows[rows.length - 1];
                                break;
                            }
                        }
                    }
                }
                
                if (nextRow) {
                    const nextInput = nextRow.querySelectorAll('input[type="number"]')[currentColumn];
                    if (nextInput) {
                        const nextIndex = allInputs.indexOf(nextInput);
                        return nextIndex;
                    }
                }
                
                return -1;
            }
            
            function findNextColumnInput(currentInput, direction) {
                const allInputs = Array.from(document.querySelectorAll('.data-table input[type="number"]'));
                const currentIndex = allInputs.indexOf(currentInput);
                const currentRow = currentInput.closest('tr');
                const rowInputs = Array.from(currentRow.querySelectorAll('input[type="number"]'));
                const currentColumn = rowInputs.indexOf(currentInput);
                
                let nextInput;
                if (direction > 0) {
                    if (currentColumn < rowInputs.length - 1) {
                        nextInput = rowInputs[currentColumn + 1];
                    } else {
                        // 移到下一行的第一列
                        return findNextRowInput(currentInput, 1);
                    }
                } else {
                    if (currentColumn > 0) {
                        nextInput = rowInputs[currentColumn - 1];
                    } else {
                        // 移到上一行的最後一列
                        const prevRowIndex = findNextRowInput(currentInput, -1);
                        if (prevRowIndex !== -1) {
                            const prevInput = allInputs[prevRowIndex];
                            const prevRow = prevInput.closest('tr');
                            const prevRowInputs = Array.from(prevRow.querySelectorAll('input[type="number"]'));
                            nextInput = prevRowInputs[prevRowInputs.length - 1];
                        }
                    }
                }
                
                if (nextInput) {
                    return allInputs.indexOf(nextInput);
                }
                
                return -1;
            }

            // 新增數據列
            addRowBtn1.addEventListener('click', () => addRow(dataTable1.querySelector('tbody'), 1));
            addRowBtn2.addEventListener('click', () => addRow(dataTable2.querySelector('tbody'), 2));
            addRowBtn3.addEventListener('click', () => addRow(dataTable3.querySelector('tbody'), 3));

            function addRow(tableBody, groupNum) {
                const rowCount = tableBody.children.length;
                const baseTabIndex = groupNum * 100 + rowCount * 10;
                
                const newRow = tableBody.insertRow();
                newRow.innerHTML = `
                    <td><input type="number" class="concentration" step="any" tabindex="${baseTabIndex + 1}"></td>
                    <td><input type="number" class="total" min="1" tabindex="${baseTabIndex + 2}"></td>
                    <td><input type="number" class="dead" min="0" tabindex="${baseTabIndex + 3}"></td>
                    <td><span class="mortality-display">--</span></td>
                `;
                attachInputListeners(newRow);
                setupKeyboardNavigation();
            }

            // 附加輸入監聽器來自動計算死亡率
            function attachInputListeners(row) {
                const totalInput = row.querySelector('.total');
                const deadInput = row.querySelector('.dead');
                const mortalityDisplay = row.querySelector('.mortality-display');
                
                function updateMortality() {
                    const total = parseInt(totalInput.value);
                    const dead = parseInt(deadInput.value);
                    
                    if (!isNaN(total) && !isNaN(dead) && total > 0) {
                        if (dead > total) {
                            deadInput.value = total;
                        }
                        const mortality = (parseInt(deadInput.value) / total * 100).toFixed(1);
                        mortalityDisplay.textContent = mortality + '%';
                    } else {
                        mortalityDisplay.textContent = '--';
                    }
                }

                totalInput.addEventListener('input', updateMortality);
                deadInput.addEventListener('input', updateMortality);
            }
            
            // 初始化現有行的監聽器和鍵盤導航
            document.querySelectorAll('.data-table tbody tr').forEach(attachInputListeners);
            setupKeyboardNavigation();

            // 處理 Excel 貼上功能
            document.querySelectorAll('.data-table').forEach(table => {
                table.addEventListener('paste', (event) => {
                    const tableBody = table.querySelector('tbody');
                    let pasteData = event.clipboardData.getData('text/plain');
                    let rows = pasteData.trim().split('\n');
                    
                    // 清空現有表格內容
                    tableBody.innerHTML = '';
                    
                    const tableId = table.id;
                    const groupNum = parseInt(tableId.split('-')[2]);
                    
                    rows.forEach((rowString, index) => {
                        const cols = rowString.trim().split(/[\t\s]+/);
                        if (cols.length >= 3) {
                            const baseTabIndex = groupNum * 100 + index * 10;
                            const newRow = tableBody.insertRow();
                            const concentration = parseFloat(cols[0]);
                            const total = parseInt(cols[1]);
                            const dead = parseInt(cols[2]);
                            
                            const mortality = (!isNaN(total) && !isNaN(dead) && total > 0) ? (dead / total * 100).toFixed(1) : '--';

                            newRow.innerHTML = `
                                <td><input type="number" class="concentration" step="any" value="${cols[0]}" tabindex="${baseTabIndex + 1}"></td>
                                <td><input type="number" class="total" min="1" value="${cols[1]}" tabindex="${baseTabIndex + 2}"></td>
                                <td><input type="number" class="dead" min="0" value="${cols[2]}" tabindex="${baseTabIndex + 3}"></td>
                                <td><span class="mortality-display">${mortality}%</span></td>
                            `;
                            attachInputListeners(newRow);
                        }
                    });
                    setupKeyboardNavigation();
                    event.preventDefault();
                });
            });

            // 重設按鈕功能
            resetBtn.addEventListener('click', () => {
                dataTable1.querySelector('tbody').innerHTML = `<tr><td><input type="number" class="concentration" step="any" tabindex="1"></td><td><input type="number" class="total" min="1" tabindex="2"></td><td><input type="number" class="dead" min="0" tabindex="3"></td><td><span class="mortality-display">--</span></td></tr>`;
                dataTable2.querySelector('tbody').innerHTML = `<tr><td><input type="number" class="concentration" step="any" tabindex="101"></td><td><input type="number" class="total" min="1" tabindex="102"></td><td><input type="number" class="dead" min="0" tabindex="103"></td><td><span class="mortality-display">--</span></td></tr>`;
                dataTable3.querySelector('tbody').innerHTML = `<tr><td><input type="number" class="concentration" step="any" tabindex="201"></td><td><input type="number" class="total" min="1" tabindex="202"></td><td><input type="number" class="dead" min="0" tabindex="203"></td><td><span class="mortality-display">--</span></td></tr>`;
                
                // 重新附加監聽器
                document.querySelectorAll('.data-table tbody tr').forEach(attachInputListeners);
                setupKeyboardNavigation();

                resultsSection.style.display = 'none';
                resultsGroup2.style.display = 'none';
                resultsGroup3.style.display = 'none';
                exportPdfBtn.style.display = 'none';
                if (probitChart) {
                    probitChart.destroy();
                }
            });

            // 主要計算功能
            calculateBtn.addEventListener('click', () => {
                try {
                    const data1 = getDataFromTable(dataTable1);
                    const data2 = getDataFromTable(dataTable2);
                    const data3 = getDataFromTable(dataTable3);

                    if (data1.length < 3) {
                        showError('第一組數據請至少輸入三組有效數據以確保統計計算的可靠性。');
                        return;
                    }

                    // 驗證數據質量
                    const validation1 = validateData(data1);
                    if (!validation1.isValid) {
                        showError(`第一組數據驗證失敗：${validation1.message}`);
                        return;
                    }

                    const probitResults1 = calculateProbit(data1);
                    displayResults(probitResults1, 1);

                    let datasets = createChartDatasets(data1, probitResults1, 1);
                    let validationText = `${group1NameInput.value}：${validation1.message}`;

                    if (data2.length >= 3) {
                        const validation2 = validateData(data2);
                        if (validation2.isValid) {
                            const probitResults2 = calculateProbit(data2);
                            displayResults(probitResults2, 2);
                            datasets = datasets.concat(createChartDatasets(data2, probitResults2, 2));
                            validationText += `<br>${group2NameInput.value}：${validation2.message}`;
                            resultsGroup2.style.display = 'block';
                        } else {
                            validationText += `<br>${group2NameInput.value}：驗證失敗 - ${validation2.message}`;
                        }
                    }

                    if (data3.length >= 3) {
                        const validation3 = validateData(data3);
                        if (validation3.isValid) {
                            const probitResults3 = calculateProbit(data3);
                            displayResults(probitResults3, 3);
                            datasets = datasets.concat(createChartDatasets(data3, probitResults3, 3));
                            validationText += `<br>${group3NameInput.value}：${validation3.message}`;
                            resultsGroup3.style.display = 'block';
                        } else {
                            validationText += `<br>${group3NameInput.value}：驗證失敗 - ${validation3.message}`;
                        }
                    }

                    validationDetails.innerHTML = validationText;
                    resultsSection.style.display = 'block';
                    exportPdfBtn.style.display = 'inline-block';
                    renderChart(datasets);

                } catch (e) {
                    showError('計算失敗：' + e.message);
                }
            });

            function getDataFromTable(table) {
                const data = [];
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => {
                    const concentration = parseFloat(row.querySelector('.concentration').value);
                    const total = parseInt(row.querySelector('.total').value);
                    const dead = parseInt(row.querySelector('.dead').value);

                    if (!isNaN(concentration) && !isNaN(total) && total > 0 && !isNaN(dead)) {
                        data.push({
                            concentration: concentration,
                            total: total,
                            dead: dead
                        });
                    }
                });
                return data;
            }

            function validateData(data) {
                if (data.length < 3) {
                    return { isValid: false, message: '數據點少於三個，無法進行統計計算。' };
                }

                // 檢查是否所有濃度都相同
                const uniqueConcentrations = new Set(data.map(d => d.concentration));
                if (uniqueConcentrations.size < data.length) {
                    return { isValid: false, message: '濃度值重複，請確保每組濃度都是唯一的。' };
                }

                // 檢查是否有 0% 或 100% 死亡率的數據
                const hasZeroMortality = data.some(d => d.dead === 0);
                const hasHundredMortality = data.some(d => d.dead === d.total);
                
                if (hasZeroMortality && hasHundredMortality) {
                    // 檢查是否有介於 0% 和 100% 之間的中間死亡率
                    const hasIntermediateMortality = data.some(d => d.dead > 0 && d.dead < d.total);
                    if (!hasIntermediateMortality) {
                        return { isValid: false, message: '數據中只有 0% 或 100% 死亡率，無法進行 Probit 分析。請至少提供一組中間死亡率的數據。' };
                    }
                }
                
                // 檢查濃度值是否遞增
                for (let i = 1; i < data.length; i++) {
                    if (data[i].concentration <= data[i-1].concentration) {
                        return { isValid: false, message: '濃度值必須為遞增排序。' };
                    }
                }

                // 檢查死亡數是否隨著濃度增加而增加
                for (let i = 1; i < data.length; i++) {
                    const mortality_i = data[i].dead / data[i].total;
                    const mortality_i_minus_1 = data[i-1].dead / data[i-1].total;
                    if (mortality_i < mortality_i_minus_1) {
                         return { isValid: false, message: `死亡率未隨濃度遞增。濃度 ${data[i-1].concentration} 的死亡率(${mortality_i_minus_1.toFixed(2)}%) 高於濃度 ${data[i].concentration} 的死亡率(${mortality_i.toFixed(2)}%)。` };
                    }
                }

                return { isValid: true, message: `數據驗證通過，共 ${data.length} 個有效數據點。` };
            }

            // Probit 分析核心函式 - 重寫以提高穩定性
            function calculateProbit(data) {
                // 處理極值數據，避免 log(0) 或 Probit(0)
                let adjustedData = data.map(d => {
                    let adjustedMortality;
                    if (d.dead === 0) {
                        adjustedMortality = 0.5 / d.total;
                    } else if (d.dead === d.total) {
                        adjustedMortality = (d.total - 0.5) / d.total;
                    } else {
                        adjustedMortality = d.dead / d.total;
                    }
                    return {
                        logConcentration: Math.log10(d.concentration),
                        probit: probitFunction(adjustedMortality),
                        mortality: adjustedMortality,
                        total: d.total,
                        dead: d.dead
                    };
                });

                // 檢查調整後的數據是否有 NaN 或 Infinity
                const hasInvalidData = adjustedData.some(d => isNaN(d.logConcentration) || isNaN(d.probit) || !isFinite(d.logConcentration) || !isFinite(d.probit));
                if (hasInvalidData) {
                    // 如果數據包含無效值，可能是濃度為0或負數
                    return {
                        lc50: NaN, ciLower: NaN, ciUpper: NaN, lc75: NaN, lc90: NaN, slope: NaN, rSquared: NaN,
                        regressionEquation: '計算失敗'
                    };
                }

                // 執行線性回歸
                const n = adjustedData.length;
                let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                
                adjustedData.forEach(d => {
                    sumX += d.logConcentration;
                    sumY += d.probit;
                    sumXY += d.logConcentration * d.probit;
                    sumX2 += d.logConcentration * d.logConcentration;
                });

                const b = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX); // 斜率
                const a = (sumY / n) - b * (sumX / n); // 截距

                // 計算 R-squared
                let sumY2 = 0, ssTotal = 0, ssResidual = 0;
                adjustedData.forEach(d => {
                    sumY2 += d.probit * d.probit;
                    const yPredicted = a + b * d.logConcentration;
                    ssTotal += (d.probit - (sumY / n)) * (d.probit - (sumY / n));
                    ssResidual += (d.probit - yPredicted) * (d.probit - yPredicted);
                });
                const rSquared = 1 - (ssResidual / ssTotal);
                
                // 計算 LC 值
                const lc50 = Math.pow(10, (5 - a) / b);
                const lc75 = Math.pow(10, (5.67 - a) / b);
                const lc90 = Math.pow(10, (6.28 - a) / b);

                // 計算 95% 信賴區間
                let sxx = sumX2 - (sumX * sumX) / n;
                let s_y_x_squared = ssResidual / (n - 2);
                const s_b = Math.sqrt(s_y_x_squared / sxx);
                const t = 2.447; // t-value for n-2=3, alpha=0.05
                const confidenceInterval = t * s_b;
                const lc50_ci_lower_log = (5 - a) / b - (t * Math.sqrt(s_y_x_squared / (b * b * sxx)));
                const lc50_ci_upper_log = (5 - a) / b + (t * Math.sqrt(s_y_x_squared / (b * b * sxx)));
                
                const ciLower = Math.pow(10, lc50_ci_lower_log);
                const ciUpper = Math.pow(10, lc50_ci_upper_log);

                return {
                    lc50,
                    lc75,
                    lc90,
                    slope: b,
                    rSquared,
                    ciLower,
                    ciUpper,
                    a,
                    b,
                    regressionEquation: `Y = ${a.toFixed(3)} + ${b.toFixed(3)}X`
                };
            }

            // 將死亡率轉換為 probit 單位
            function probitFunction(p) {
                // 使用正態分佈累積函數的反函數
                if (p === 0) return -Infinity;
                if (p === 1) return Infinity;
                
                const erf_inv = (x) => {
                    let a = 0.147;
                    let the_sign_of_x = (x >= 0) ? 1 : -1;
                    let log_x = Math.log(1 - x * x);
                    let ret = the_sign_of_x * Math.sqrt(Math.sqrt(Math.pow(2 / (Math.PI * a) + log_x / 2, 2) - log_x / a) - (2 / (Math.PI * a) + log_x / 2));
                    return ret;
                };

                return 5 + Math.sqrt(2) * erf_inv(2 * p - 1);
            }

            // 顯示結果
            function displayResults(results, groupNum) {
                const unit = (unitSelect.value === 'custom' && customUnitInput.value) ? customUnitInput.value : unitSelect.value;
                
                document.getElementById(`lc50-result-${groupNum}`).textContent = results && !isNaN(results.lc50) ? `${results.lc50.toFixed(3)} ${unit}` : '--';
                document.getElementById(`lc50-ci-${groupNum}`).textContent = results && !isNaN(results.ciLower) && !isNaN(results.ciUpper) ? `95% CI: ${results.ciLower.toFixed(3)}-${results.ciUpper.toFixed(3)} ${unit}` : '--';
                document.getElementById(`lc75-result-${groupNum}`).textContent = results && !isNaN(results.lc75) ? `${results.lc75.toFixed(3)} ${unit}` : '--';
                document.getElementById(`lc90-result-${groupNum}`).textContent = results && !isNaN(results.lc90) ? `${results.lc90.toFixed(3)} ${unit}` : '--';
                document.getElementById(`slope-result-${groupNum}`).textContent = results && !isNaN(results.slope) && !isNaN(results.rSquared) ? `${results.slope.toFixed(3)} (R²=${results.rSquared.toFixed(3)})` : '--';
            }

            function createChartDatasets(data, results, groupNum) {
                const groupName = document.getElementById(`group${groupNum}-name`).value || `實驗組 ${String.fromCharCode(64 + groupNum)}`;
                const colors = ['#667eea', '#11998e', '#606c88'];
                const pointColor = colors[groupNum - 1];
                const lineColor = colors[groupNum - 1];

                // 創建散點圖數據
                const scatterData = data.map(d => {
                    const mortalityRate = d.dead / d.total;
                    const probitValue = probitFunction(mortalityRate === 0 ? 0.5 / d.total : mortalityRate === 1 ? (d.total - 0.5) / d.total : mortalityRate);
                    return {
                        x: d.concentration,
                        y: probitValue
                    };
                });

                // 創建回歸線數據
                const minLogC = Math.log10(Math.min(...data.map(d => d.concentration)));
                const maxLogC = Math.log10(Math.max(...data.map(d => d.concentration)));

                const lineData = [
                    {
                        x: Math.pow(10, minLogC),
                        y: results.a + results.b * minLogC
                    },
                    {
                        x: Math.pow(10, maxLogC),
                        y: results.a + results.b * maxLogC
                    }
                ];

                return [
                    {
                        label: `${groupName} 實驗數據點`,
                        data: scatterData,
                        backgroundColor: pointColor,
                        borderColor: pointColor,
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        showLine: false,
                        fill: false,
                        type: 'scatter'
                    },
                    {
                        label: `${groupName} 回歸線`,
                        data: lineData,
                        borderColor: lineColor,
                        borderWidth: 2,
                        fill: false,
                        type: 'line',
                        tension: 0.1,
                        pointRadius: 0
                    }
                ];
            }

            function renderChart(datasets) {
                const ctx = document.getElementById('probit-chart').getContext('2d');
                if (probitChart) {
                    probitChart.destroy();
                }

                probitChart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        label += `濃度: ${context.parsed.x.toFixed(2)}，Probit值: ${context.parsed.y.toFixed(2)}`;
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'logarithmic',
                                title: {
                                    display: true,
                                    text: `濃度 (${(unitSelect.value === 'custom' && customUnitInput.value) ? customUnitInput.value : unitSelect.value})`
                                },
                                min: Math.log10(Math.min(...datasets.flatMap(d => d.data).map(d => d.x))),
                                max: Math.log10(Math.max(...datasets.flatMap(d => d.data).map(d => d.x)))
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Probit 單位 (Y)'
                                },
                                min: 2,
                                max: 8,
                                ticks: {
                                    callback: function(value, index, values) {
                                        return value;
                                    }
                                }
                            }
                        }
                    }
                });
            }

            // 匯出 PDF 功能
            exportPdfBtn.addEventListener('click', () => {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF('p', 'mm', 'a4');
                let yPosition = 20;

                // 添加標題
                doc.setFont('NotoSansTC');
                doc.setFontSize(18);
                doc.text('LC50/LC75/LC90 分析報告', 105, yPosition, { align: 'center' });
                yPosition += 10;
                doc.setFontSize(10);
                doc.text(`生成時間: ${new Date().toLocaleString('zh-TW', { timeZone: 'Asia/Taipei' })}`, 105, yPosition, { align: 'center' });
                yPosition += 15;

                // 添加 LC 值結果
                const resultsTableData = [];
                for (let i = 1; i <= 3; i++) {
                    const resultsGroup = document.getElementById(`results-group-${i}`);
                    if (resultsGroup.style.display !== 'none') {
                        const groupTitle = document.getElementById(`results-title-${i}`).textContent;
                        const unit = (unitSelect.value === 'custom' && customUnitInput.value) ? customUnitInput.value : unitSelect.value;
                        
                        const lc50 = document.getElementById(`lc50-result-${i}`).textContent;
                        const lc50CI = document.getElementById(`lc50-ci-${i}`).textContent;
                        const lc75 = document.getElementById(`lc75-result-${i}`).textContent;
                        const lc90 = document.getElementById(`lc90-result-${i}`).textContent;
                        const slope = document.getElementById(`slope-result-${i}`).textContent;
                        
                        resultsTableData.push([
                            groupTitle,
                            `LC50: ${lc50}`,
                            `95% CI: ${lc50CI}`,
                            `LC75: ${lc75}`,
                            `LC90: ${lc90}`,
                            `回歸線斜率: ${slope}`
                        ]);
                    }
                }

                doc.setFont('NotoSansTC');
                doc.setFontSize(12);
                doc.text('計算結果', 20, yPosition);
                yPosition += 8;
                doc.setFontSize(10);
                
                doc.autoTable({
                    startY: yPosition,
                    head: [['實驗組', 'LC50', '95% CI', 'LC75', 'LC90', '回歸線斜率']],
                    body: resultsTableData.map(row => [row[0], row[1], row[2], row[3], row[4], row[5]]),
                    theme: 'grid',
                    styles: { font: 'NotoSansTC', overflow: 'linebreak' },
                    headStyles: { fillColor: [102, 126, 234], textColor: 255 },
                    columnStyles: { 0: { cellWidth: 35 }, 1: { cellWidth: 30 }, 2: { cellWidth: 40 }, 3: { cellWidth: 30 }, 4: { cellWidth: 30 }, 5: { cellWidth: 30 } },
                    didDrawPage: (data) => {
                        yPosition = data.cursor.y + 10;
                    }
                });
                
                // 添加統計驗證結果
                doc.setFont('NotoSansTC');
                doc.setFontSize(12);
                doc.text('統計驗證', 20, yPosition);
                yPosition += 8;
                doc.setFont('NotoSansTC');
                doc.setFontSize(10);
                const validationText = validationDetails.innerHTML.replace(/<br>/g, '\n').replace(/<[^>]*>/g, '');
                const splitText = doc.splitTextToSize(validationText, 170);
                doc.text(splitText, 20, yPosition);
                yPosition += splitText.length * 5 + 10;
                
                // 添加圖表
                if (yPosition > 220) {
                    doc.addPage();
                    yPosition = 20;
                }
                
                doc.setFont('NotoSansTC');
                doc.setFontSize(12);
                doc.text('Probit 分析圖', 20, yPosition);
                
                html2canvas(document.getElementById('probit-chart')).then(canvas => {
                    const imgData = canvas.toDataURL('image/png');
                    const imgWidth = 170;
                    const imgHeight = canvas.height * imgWidth / canvas.width;
                    
                    if (yPosition + imgHeight > 280) {
                        doc.addPage();
                        yPosition = 20;
                    }
                    
                    doc.addImage(imgData, 'PNG', 20, yPosition + 10, imgWidth, imgHeight);
                    doc.save('LC50_Analysis_Report.pdf');
                });
            });
        });
    </script>
</body>
</html>
